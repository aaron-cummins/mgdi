// Generated by CodiumAI

/*
Code Analysis

Objective:
The Aplicacion function is a React component that renders a header, a table, and a modal for managing applications. Its main objective is to provide a user interface for creating, updating, and deleting applications.

Inputs:
The Aplicacion function does not receive any inputs.

Flow:
1. The useStateContext hook is used to get the current color from the state context.
2. The state variable openModal and the function setOpenModal are initialized using the useState hook.
3. The AplicacionContextProvider component is rendered to provide the application context to its children.
4. The Header component is rendered with the category "Administración" and the title "Aplicación". It also includes a button for creating a new application.
5. The TablaAplicacion component is rendered to display a table with the list of applications. It also includes a button for editing an application.
6. The Modal component is rendered with the FormAplicacion component inside. It is used for creating or editing an application.
7. When the user clicks the button for creating a new application, the state variable openModal is set to true, and the Modal component is displayed.
8. When the user clicks the button for editing an application, the state variable openModal is set to true, and the Modal component is displayed with the selected application.
9. When the user closes the Modal component, the state variable openModal is set to false, and the Modal component is hidden.

Outputs:
The Aplicacion function does not have any direct outputs. Its main purpose is to render the user interface for managing applications.

Additional aspects:
- The AplicacionContextProvider component provides the application context to its children using the useContext hook.
- The TablaAplicacion component uses the useContext hook to get the application context and display the list of applications.
- The FormAplicacion component is used for creating or editing an application. It uses the useContext hook to get the application context and the useSnackbar and useValidacionForm hooks for form validation and error handling.
*/
import { fireEvent, render, renderHook, screen, waitFor } from "@testing-library/react";
import { Aplicacion } from "pages";
import FormAplicacion from "pages/aplicacion/components/FormAplicacion";
import TablaAplicacion from "pages/aplicacion/components/TablaAplicacion";
import { AplicacionContext } from "pages/aplicacion/context/aplicacionContext";
import { act } from "react-test-renderer";
import { deleteObject, getByID, getList, postObject, putObject } from "services/genericService";

describe("Aplicacion_function", () => {
  // Tests that the Header and Modal components render correctly.
  it("test_header_and_modal_render_correctly", () => {
    render(<Aplicacion />);
    expect(screen.getByText("Administración")).toBeInTheDocument();
    expect(screen.getByText("Aplicación")).toBeInTheDocument();
    expect(screen.getByText("Nueva Aplicación")).toBeInTheDocument();
    expect(screen.queryByText("Aplicación creada con exito!")).not.toBeInTheDocument();
    expect(screen.queryByText("Debe corregir los problemas en el formulario")).not.toBeInTheDocument();
  });

  // Tests that the FormAplicacion component handles input changes correctly.
  it("test_form_aplicacion_handles_input_changes_correctly", () => {
    render(<FormAplicacion />);
    const inputNombre = screen.getByLabelText("Nombre");
    fireEvent.change(inputNombre, { target: { value: "Test" } });
    expect(inputNombre.value).toBe("Test");
  });

  // Tests error handling in obtenerAplicaciones, obtenerAplicacion, registrarAplicacion, actualizarAplicacion, and eliminarAplicacion functions.
  it("test_error_handling_in_obtener_functions", async () => {
    const mockCallEndpoint = jest.fn();
    mockCallEndpoint.mockRejectedValueOnce(new Error("Error"));
    const { result } = renderHook(() => AplicacionContext());
    result.current.dispatch = jest.fn();
    result.current.callEndpoint = mockCallEndpoint;
    await act(async () => {
      await result.current.obtenerAplicaciones();
    });
    expect(result.current.dispatch).toHaveBeenCalledTimes(0);
    expect(mockCallEndpoint).toHaveBeenCalledTimes(1);
    expect(mockCallEndpoint).toHaveBeenCalledWith(getList("aplicacion"));

    mockCallEndpoint.mockRejectedValueOnce(new Error("Error"));
    await act(async () => {
      await result.current.obtenerAplicacion({ id: 1 });
    });
    expect(result.current.dispatch).toHaveBeenCalledTimes(0);
    expect(mockCallEndpoint).toHaveBeenCalledTimes(1);
    expect(mockCallEndpoint).toHaveBeenCalledWith(getByID("aplicacion", 1));

    mockCallEndpoint.mockRejectedValueOnce(new Error("Error"));
    await act(async () => {
      await result.current.registrarAplicacion({});
    });
    expect(result.current.dispatch).toHaveBeenCalledTimes(0);
    expect(mockCallEndpoint).toHaveBeenCalledTimes(1);
    expect(mockCallEndpoint).toHaveBeenCalledWith(postObject("aplicacion", {}));

    mockCallEndpoint.mockRejectedValueOnce(new Error("Error"));
    await act(async () => {
      await result.current.actualizarAplicacion({});
    });
    expect(result.current.dispatch).toHaveBeenCalledTimes(0);
    expect(mockCallEndpoint).toHaveBeenCalledTimes(1);
    expect(mockCallEndpoint).toHaveBeenCalledWith(putObject("aplicacion", {}));

    mockCallEndpoint.mockRejectedValueOnce(new Error("Error"));
    await act(async () => {
      await result.current.eliminarAplicacion(1);
    });
    expect(result.current.dispatch).toHaveBeenCalledTimes(0);
    expect(mockCallEndpoint).toHaveBeenCalledTimes(1);
    expect(mockCallEndpoint).toHaveBeenCalledWith(deleteObject("aplicacion", 1));
  });

  // Tests that the TablaAplicacion component correctly displays data.
  it("test_tabla_aplicacion_correctly_displays_data", () => {
    const aplicacionList = [
      { id: 1, nombre: "Aplicacion 1", activo: true },
      { id: 2, nombre: "Aplicacion 2", activo: false },
    ];
    const obtenerAplicaciones = jest.fn();
    const obtenerAplicacion = jest.fn();
    const openModal = jest.fn();
    render(
      <AplicacionContext.Provider value={{ aplicacionList, obtenerAplicaciones, obtenerAplicacion }}>
        <TablaAplicacion openModal={openModal} />
      </AplicacionContext.Provider>
    );
    expect(screen.getByText("Aplicacion 1")).toBeInTheDocument();
    expect(screen.getByText("Aplicacion 2")).toBeInTheDocument();
  });

  // Tests that the FormAplicacion component correctly handles input validation.
  it("test_form_aplicacion_correctly_handles_input_validation", () => {
    const registrarAplicacion = jest.fn();
    const actualizarAplicacion = jest.fn();
    const obtenerAplicacion = jest.fn();
    const closeModal = jest.fn();
    render(
      <AplicacionContext.Provider value={{ registrarAplicacion, actualizarAplicacion, obtenerAplicacion }}>
        <FormAplicacion closeModal={closeModal} />
      </AplicacionContext.Provider>
    );
    const nombreInput = screen.getByLabelText("Nombre");
    fireEvent.change(nombreInput, { target: { value: "" } });
    fireEvent.blur(nombreInput);
    expect(screen.getByText("Nombre requerido")).toBeInTheDocument();
  });

  // Tests that the FormAplicacion component correctly handles form submission.
  it("test_form_aplicacion_correctly_handles_form_submission", async () => {
    const registrarAplicacion = jest.fn(() =>
      Promise.resolve({ tipoAlerta: "success", mensaje: "Aplicación creada con exito!" })
    );
    const actualizarAplicacion = jest.fn(() =>
      Promise.resolve({ tipoAlerta: "success", mensaje: "Aplicación actualizada con exito!" })
    );
    const obtenerAplicacion = jest.fn();
    const closeModal = jest.fn();
    const enqueueSnackbar = jest.fn();
    const { getByText, getByLabelText } = render(
      <AplicacionContext.Provider value={{ registrarAplicacion, actualizarAplicacion, obtenerAplicacion }}>
        <FormAplicacion closeModal={closeModal} />
      </AplicacionContext.Provider>
    );
    const nombreInput = screen.getByLabelText("Nombre");
    fireEvent.change(nombreInput, { target: { value: "Nueva Aplicacion" } });
    fireEvent.blur(nombreInput);
    fireEvent.submit(screen.getByText("Guardar"));
    await waitFor(() => expect(registrarAplicacion).toHaveBeenCalled());
    expect(enqueueSnackbar).toHaveBeenCalledWith("Aplicación creada con exito!", { variant: "success" });
  });
});
